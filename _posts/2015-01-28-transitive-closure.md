---
layout: post
title: "传递闭包"
description: ""
category: 
tags: []
---
{% include JB/setup %}
传递闭包：在数学上的定义——在集合X上的二元关系R的传递闭包是包含R的X上的最小传递关系。其中定义域是数据集X，而运算关系是必须具有传递性，这里的最小传递关系则可根据传递关系来具体定义。
下面通过一个实例，通过问题的解决来加深理解。

学院举办一个辩论会，请你设计一个成绩记录器，要求：先输入参赛队伍数，然后依次输入比赛场次及每场比赛结果，最后可以输入一组队伍，系统可以输出两者的胜负关系。（胜利的关系是传递，且双方只战一场。例：A胜了B，B胜了C，则可以A胜了C。如果无法传递胜负关系则输出不能判断。）

不难发现这就是一个闭包问题。我们来做一下对应。X就是所有参赛队的集合；二元关系就是胜利，从题目叙述它正好符合传递性；通过这个问题的对应，我们就可以构建这个传递闭包了。接下来我们将用图算法来解决这个问题，在解决之前，我们先对图进行一个初步的了解。

对于图G=(V，E),最重要的两个元素就是V(顶点或结点）和E（边）。很明显对于以上问题，每个参赛队就是一个结点，每两队之间的胜负关系则构成一条边，这个图就很容的建立了。

图有两种表示方法：1）邻接链表；2）邻接矩阵。邻接链表就是把每一个可以两两邻接直达的关系连接构成一个链表，这样就会构成多个链表。邻接矩阵的实现则相对简单，它就是把每个结点生成一个二维矩阵的一行或者一列，矩阵的每一个元素则代表了对应两个结点的胜负关系。
对比以上两种方法，很明显的，邻接链表方法构建复杂（结点操作）。而邻接矩阵只是对二维数组对应点的赋值以及检索处理。

根据边是否有方向，图可以分为有向图和无向图。其中无向图（两点之间路径都可达）对应的实际问题就是结点对间最短路径的问题，这个问题在此不再赘述。有向图（两人之间胜负关系单向）就是传递闭包问题，我们实际就是解决了一个有向图的问题。

今天我们就来分享一种解决邻接矩阵的floyed-Warshall算法。算法的思路很简单，就是利用三重循环来检索，实质就寻求目标两个结点（两重循环）和中间结点（一重循环）之间的关系来判断目标两个结点的关系。对于本问题的代码我们可以直接写出如下：

	for(int i=0;i<N;i++)
		for(int j=0;j<N;j++)
			str[i][j]=1000; 				  //关系矩阵初始化，未定胜负设置为1000
	cin>>a>>b;  							  //此输入代表a战胜了b(为了和矩阵索引对应，输入为数字，代表相应队伍编号)
	str[a-1][b-1]=1;        					  //设置对应元素为1，表示a战胜b。索引减1是因为C语言的矩阵索引由0开始。
	/*********以下是floyed-warshall算法部分**********/
	for(int i=0;i<N;i++)    
		for(int j=0;j<N;j++) 					  //目标节点循环
			for(int k=0;k<N;k++) 				  //中间结点循环
				if((str[i][j]==1&&str[j][k]==1)  	  //检测传递
				{
					str[i][k]=1;
				}
	
	
至此，问题核心部分就已解决，输入任意队伍组，即可输出二者之间的胜负关系了。但是问题出现了，上述解决似乎忽略了一个闭环的问题；例如，如果三场结果是a战胜b，b战胜c，c战胜a，这就构成了一个闭环。我们分析上述代码，生成上不会有问题，
但是在算法执行中检测到	str[a-1][b-1]==1&&str[b-1][c-1]==1 则会把str[a-1][c-1]置1。此时显示1战胜了3，而实际3战胜了1.为解决此问题，我们可修改代码如下：

	for(int i=0;i<N;i++)
		for(int j=0;j<N;j++)
			str[i][j]=1000; 				  //关系矩阵初始化，未定胜负设置为1000
	cin>>a>>b;  							  //此输入代表a战胜了b(为了和矩阵索引对应，输入为数字，代表相应队伍编号)
	str[a-1][b-1]=1;        					  //设置对应元素为1，表示a战胜b。索引减1是因为C语言的矩阵索引由0开始。
	str[b-1][a-1]=0;						  //设置对应元素为O, 表示b负于a。这是防止闭环出现。
	/*********以下是floyed-warshall算法部分**********/
	for(int i=0;i<N;i++)    
		for(int j=0;j<N;j++) 					  //目标节点循环
			for(int k=0;k<N;k++) 				  //中间结点循环
				if((str[i][j]+str[j][k]==2)&&str[i][k]>0) //检测传递防止闭环
				{
					str[i][k]=1;
					str[k][i]=0;
				}

修改后的代码中，在生成时，只有两两交战的结果，所以一旦一方获胜自然另一方为负（仅赛一场）。所以可以再设置a胜b的同时，设置b负于a的标志（设置0）;
修改floyed算法的判断语句，在检测传递的同时，判断是否两者胜负关系直接已定。由此防止闭环现象的出现，同时设置双方胜负关系。至此算法问题已经解决。
如果矩阵稀疏度很大，即V*V远远大于E，这样矩阵的有效数据则会很少，在矩阵数很大的情况下，这会使运行效率大大降低。对于解决稀疏矩阵，有专门的Jhonson算法，
在此，我们仅从改进floyed算法的做出处理。

	//矩阵构建部分同上
	/************改进floyed算法二*************/
	for(int k=0;k<N;k++)					//变中间结点的内层循环为外层循环
		for(int i=0;i<N;i++)				
		{
			if(str[i][k]<1000)				//判断一个目标节点结点和中间结点的关系，如不能确定则没有必要判断另一目标结点
			{
				for(int j=0;j<N;j++)
				{
					if((str[i][j]+str[j][k]==2)&&str[i][k]>0)
					{
						str[i][k]=1;
						str[k][i]=0;
					}
				}
			}
		}
	
至此，floyed在有向图问题的应用和改进都已完善，对于floyed在无向图的应用，则在以后微博中分享。

